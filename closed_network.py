# -*- coding: utf-8 -*-
"""1d_hemo_solver_branch_network.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/Riky2014/Tesi/blob/main/1d_hemo_solver_branch_network.ipynb
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !apt-get install software-properties-common
# !add-apt-repository -y ppa:fenics-packages/fenics
# !apt-get update -qq
# !apt install fenics
# 
# !git config --global user.name "Riky2014"
# !git config --global user.email "riccardo.petrucci2014@gmail.com"
# 
# username = "Riky2014"
# token = "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"
# repo = "Tesi"
# 
# !git clone https://{token}@github.com/{username}/{repo}

# from google.colab import drive
# drive.mount('/content/drive')

from fenics import *

import os
import csv
import pickle
import logging
import numpy as np
from tqdm import tqdm
import matplotlib.pyplot as plt

# Set the logging level to suppress FFC messages
set_log_level(LogLevel.ERROR)
logging.getLogger('FFC').setLevel(logging.ERROR)
logging.getLogger('UFL_LEGACY').setLevel(logging.WARNING)

"""# Dictionaries containing network information"""

known_inflow_data = 'flux'

branches = {
    '1': {
        'L': 1.28,
        'A0': 0.0740,
        'beta': 0.1451e7,
        'boundary': {
            'left': {'type': 'inlet'},
            'right': {'type': 'branch'}
        }
    },
    '2': {
        'L': 1.3212,
        'A0': 0.0347,
        'beta': 0.0497e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'branch'}
        }
    },
    '3': {
        'L': 3.0909,
        'A0': 0.0338,
        'beta': 0.0490e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'outlet'}
        }
    },
    '4': {
        'L': 1.1713,
        'A0': 0.0256,
        'beta': 0.0426e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'branch'}
        }
    },
    '5': {
        'L': 4.2887,
        'A0': 0.1252,
        'beta': 0.1887e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'inlet'}
        }
    },
    '6': {
        'L': 0.4203,
        'A0': 0.0756,
        'beta': 0.0733e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'branch'}
        }
    },
    '7': {
        'L': 3.0665,
        'A0': 0.0288,
        'beta': 0.0452e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'branch'}
        }
    },
    '8': {
        'L': 4.4854,
        'A0': 0.0580,
        'beta': 0.0642e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'outlet'}
        }
    },
    '9': {
        'L': 1.0012,
        'A0': 0.0295,
        'beta': 0.0458e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'branch'}
        }
    },
    '10': {
        'L': 2.5496,
        'A0': 0.0331,
        'beta': 0.0485e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'outlet'}
        }
    },
    '11': {
        'L': 1.8936,
        'A0': 0.0301,
        'beta': 0.0463e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'branch'}
        }
    },
    '12': {
        'L': 4.8650,
        'A0': 0.1260,
        'beta': 0.1893e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'inlet'}
        }
    },
    '13': {
        'L': 0.6961,
        'A0': 0.0800,
        'beta': 0.0754e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'branch'}
        }
    },
    '14': {
        'L': 2.1127,
        'A0': 0.0435,
        'beta': 0.0556e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'branch'}
        }
    },
    '15': {
        'L': 3.3325,
        'A0': 0.0623,
        'beta': 0.0666e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'outlet'}
        }
    },
    '16': {
        'L': 0.4632,
        'A0': 0.0214,
        'beta': 0.0390e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'branch'}
        }
    },
    '17': {
        'L': 4.4019,
        'A0': 0.0281,
        'beta': 0.0447e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'outlet'}
        }
    },
    '18': {
        'L': 3.9169,
        'A0': 0.0323,
        'beta': 0.0479e7,
        'boundary': {
            'left': {'type': 'branch'},
            'right': {'type': 'outlet'}
        }
    },
}


bifurcations = {
    'bif_1': {
        'branch_id': ['1', '2', '9'],
        'positions': ['right', 'left', 'left'],
        'theta': [None, 0.7748, 0.7771]
    },
    'bif_2': {
        'branch_id': ['2', '3', '4'],
        'positions': ['right', 'left', 'left'],
        'theta': [None, 0.7054, 0.9872]
    },
    'bif_3': {
        'branch_id': ['5', '4', '6'],
        'positions': ['left', 'right', 'left'],
        'theta': [None, 1.2182, 0.5778]
    },
    'bif_4': {
        'branch_id': ['6', '7', '8'],
        'positions': ['right', 'left', 'left'],
        'theta': [None, 1.9317, 0.1917]
    },
    'bif_5': {
        'branch_id': ['7', '16', '17'],
        'positions': ['right', 'left', 'left'],
        'theta': [None, 2.4837, 0.2554]
    },
    'bif_6': {
        'branch_id': ['9', '10', '11'],
        'positions': ['right', 'left', 'left'],
        'theta': [None, 0.8728, 1.1379]
    },
    'bif_7': {
        'branch_id': ['12', '13', '11'],
        'positions': ['left', 'left', 'right'],
        'theta': [None, 0.6948, 1.3204]
    },
    'bif_8': {
        'branch_id': ['13', '14', '15'],
        'positions': ['right', 'left', 'left'],
        'theta': [None, 1.0024, 0.9820]
    },
    'bif_9': {
        'branch_id': ['14', '16', '18'],
        'positions': ['right', 'right', 'left'],
        'theta': [None, 0.8910, 0.9184]
    }
}

# It will be initialized properly later
branch_boundary_conditions = {}

for branch_name, branch_data in branches.items():
    branch_boundary_conditions[branch_name] = {
        'left': {
            'A_left': 0,
            'q_left': 0
        },
        'right': {
            'A_right': 0,
            'q_right': 0
        }
    }


"""# Global Data"""

# Global data
T_base = 1
T = 1
print(f'T = {T}')

gamma_1 = 0 
gamma_2 = 2
gamma_3 = 2

mu = 0.045 # dynamic viscosity 
rho = 1.050 # density

gamma_profile = 2
alpha = (gamma_profile + 2) / (gamma_profile + 1)
k_r = 2 * np.pi * (gamma_profile + 2) * mu / rho
print(f'K_r = {k_r} ')

"""# Discretization parameter"""

# Given values
dt = 2e-5
N_T_base = int(round(T_base / dt))
N_T = int(round(T / dt))

h = 1 / 16

print(f'h = {h}')
print(f'dt = {dt}')
print(f'CFL ratio : {h / dt}')

"""## Check on dictionaries"""

def check_boundary_conditions(branches):
    allowed_boundary_types = {'inlet', 'outlet', 'branch'}
    errors = []

    for branch_id, data in branches.items():
        for side, boundary in data['boundary'].items():
            if boundary['type'] not in allowed_boundary_types:
                errors.append(f"Error in branch '{branch_id}' on '{side}' side: Invalid boundary type '{boundary['type']}'.")

    if errors:
        for error in errors:
            print(error)
    else:
        print("All boundary conditions are valid.")

def check_branching_consistency(branches, bifurcations):
    # Create a dictionary to map branch IDs to their boundary types
    branch_boundary_types = {}
    for branch_id, data in branches.items():
        for side, boundary in data['boundary'].items():
            if boundary['type'] == 'branch':
                if branch_id not in branch_boundary_types:
                    branch_boundary_types[branch_id] = {}
                branch_boundary_types[branch_id][side] = True

    # Track whether any inconsistencies are found
    inconsistencies_found = False

    # Check the bifurcation dictionary for consistency
    for bif_id, bif_data in bifurcations.items():
        branch_ids = bif_data['branch_id']
        positions = bif_data['positions']

        for i, branch_id in enumerate(branch_ids):
            if branch_id in branch_boundary_types:
                side_positions = branch_boundary_types[branch_id]

                if positions[i] not in side_positions:
                    print(f"Inconsistency found in {bif_id}: Branch '{branch_id}' expected at '{list(side_positions.keys())}' but found at '{positions[i]}'.")
                    inconsistencies_found = True
                else:
                    # If matched, remove the checked side to avoid double-checking
                    del side_positions[positions[i]]

    # Print a message if all bifurcations are consistent
    if not inconsistencies_found:
        print("All bifurcations are consistent.")

def check_known_inflow_data(known_inflow_data):
    acceptable_inflow_data = ['area', 'flux']

    if known_inflow_data not in acceptable_inflow_data:
        print(f"Invalid known inflow data: '{known_inflow_data}'. It must be either 'area' or 'flux'.")
    else:
        print(f"Known inflow data '{known_inflow_data}' is valid.")

check_boundary_conditions(branches)
check_branching_consistency(branches, bifurcations)
check_known_inflow_data(known_inflow_data)

"""# Mesh and function spaces"""

# Function to create meshes and function spaces
def create_mesh_and_function_spaces(branches, h):
    for branch_name, branch_data in branches.items():
        L = branch_data['L']
        N = int(L / h)
        mesh = IntervalMesh(N, 0, L)
        branch_data['mesh'] = mesh

        P1 = FiniteElement('P', mesh.ufl_cell(), 1)
        element = MixedElement([P1, P1])
        V = FunctionSpace(mesh, element)
        branch_data['V'] = V

        D1 = FiniteElement('DG', mesh.ufl_cell(), 0)
        element_der = MixedElement([D1, D1])
        V_der = FunctionSpace(mesh, element_der)
        branch_data['V_der'] = V_der

# Create meshes and function spaces
create_mesh_and_function_spaces(branches, h)

"""# Initial conditions"""

inflow_data_BAS = np.loadtxt('Inflow_profiles/BAS_inflow.csv', delimiter=',', skiprows=1)
inflow_data_L_ICA = np.loadtxt('Inflow_profiles/L_ICA_inflow.csv', delimiter=',', skiprows=1)
inflow_data_R_ICA = np.loadtxt('Inflow_profiles/R_ICA_inflow.csv', delimiter=',', skiprows=1)

# Function to initialize branches
def initialize_branches(branches):
    for branch_id, branch_data in branches.items():
        A0 = branch_data['A0']

        if known_inflow_data == 'area':
          q0 = 0

        elif known_inflow_data == 'flux':

          if branch_id == '5':
            inflow_data = - inflow_data_L_ICA
          elif branch_id == '12':
            inflow_data = - inflow_data_R_ICA
          else:
            inflow_data = inflow_data_BAS

          q0 = inflow_data[0][1] * A0

        V = branch_data['V']

        branch_boundary_conditions[branch_id] = {
        'left': {
            'A_left': A0,
            'q_left': q0
        },
        'right': {
            'A_right': A0,
            'q_right': q0
        }
       }

        uh_old = interpolate(Expression(('A0', 'q0'), degree=1, A0=A0, q0=q0), V)
        Ah_old, qh_old = uh_old.split()

        branch_data['uh'] = uh_old
        branch_data['Ah_old'] = Ah_old
        branch_data['qh_old'] = qh_old

"""# Functions

## Assemble matrix for algebraic formulation
"""

def H(A, q, A0, beta):
  return as_tensor([[0, 1], [beta / (2 * rho * A0) * A ** 0.5 - alpha * (q / A) ** 2, 2 * alpha * q / A]])

def F(A, q, A0, beta):
  return as_vector([q, beta / (3 * rho * A0) * A ** 1.5 - beta / (3 * rho) * A0 ** 0.5 + alpha * q ** 2 / A])

def B(A, q):
  return as_vector([0, k_r * q / A])

def S(A, q):
  return as_vector([0, k_r * q / A])

def dS_dU(A, q):
  return as_tensor([[0, 0], [- k_r * q / A ** 2, k_r / A]])

# Those are necessary to compute poinwise values for boundary condition
def U(A, q):
  return np.array([A, q])

def H_vec(A, q, A0, beta):
  return np.array([[0, 1], [beta / (2 * rho * A0) * A ** 0.5 - alpha * (q / A) ** 2, 2 * alpha * q / A]])

def B_vec(A, q):
  return np.array([0, k_r * q / A])

def S_vec(A, q):
  return np.array([0, k_r * q / A])

def c_alpha(A, q, A0, beta):
  return (beta / (2 * rho * A0) * A ** 0.5 + (q / A) ** 2 * alpha * (alpha - 1)) ** 0.5

def l1(A, q, A0, beta):
  return np.array([c_alpha(A, q, A0, beta) - alpha * q / A, 1.])

def l2(A, q, A0, beta):
  return np.array([- c_alpha(A, q, A0, beta) - alpha * q / A, 1.])

def CC(A, q, A0, beta, u_der, V_der, x):
  du_dz = project(u_der, V_der)(x)
  return U(A, q) - dt * H_vec(A, q, A0, beta) @ du_dz - dt * B_vec(A, q)

"""## Boundary condition"""

# Impose Dirichlet boundary condition at the inlet
def inlet_bc_q(A, q, A0, beta, u_der, V_der, x):
  if x < 1e-6:
    q_inlet = (np.dot(l2(A(x), q(x), A0, beta), CC(A(x), q(x), A0, beta, u_der, V_der, x)) - l2(A(x), q(x), A0, beta)[0] * U(A(x), q(x))[0] ) / l2(A(x), q(x), A0, beta)[1]
  else:
    q_inlet = (np.dot(l1(A(x), q(x), A0, beta), CC(A(x), q(x), A0, beta, u_der, V_der, x)) - l1(A(x), q(x), A0, beta)[0] * U(A(x), q(x))[0] ) / l1(A(x), q(x), A0, beta)[1]

  return q_inlet

def inlet_bc_A(A, q, A0, beta, u_der, V_der, x):
  if x < 1e-6:
    A_inlet = (np.dot(l2(A(x), q(x), A0, beta), CC(A(x), q(x), A0, beta, u_der, V_der, x)) - l2(A(x), q(x), A0, beta)[1] * U(A(x), q(x))[1] ) / l2(A(x), q(x), A0, beta)[0]
  else:
     A_inlet = (np.dot(l1(A(x), q(x), A0, beta), CC(A(x), q(x), A0, beta, u_der, V_der, x)) - l1(A(x), q(x), A0, beta)[1] * U(A(x), q(x))[1] ) / l1(A(x), q(x), A0, beta)[0]

  return A_inlet

# Impose Non Reflecting boundary condition at the outlet
def outlet_bc(A, q, A0, beta, u_der, V_der, x):
  if x < 1e-6:
    matrix = np.array([[-1, 1], [c_alpha(A(x), q(x), A0, beta) - alpha * q(x) / A(x), c_alpha(A(x), q(x), A0, beta) + alpha * q(x) / A(x)]])
    array = np.array([np.dot(l2(A(x), q(x), A0, beta), CC(A(x), q(x), A0, beta, u_der, V_der, x)), np.dot(l1(A(x), q(x), A0, beta), U(A(x), q(x)) - dt * S_vec(A(x), q(x)))])
  else:
    matrix = np.array([[1, -1], [c_alpha(A(x), q(x), A0, beta) + alpha * q(x) / A(x), c_alpha(A(x), q(x), A0, beta) - alpha * q(x) / A(x)]])
    array = np.array([np.dot(l1(A(x), q(x), A0, beta), CC(A(x), q(x), A0, beta, u_der, V_der, x)), np.dot(l2(A(x), q(x), A0, beta), U(A(x), q(x)) - dt * S_vec(A(x), q(x)))])

  A_out, q_out = matrix @ array / (2 * c_alpha(A(x), q(x), A0, beta))

  return A_out, q_out

def boundary_L(x, on_boundary):
    tol = 1E-14
    return on_boundary and near(x[0], 0, tol)

def boundary_R(x, on_boundary):
    tol = 1E-14
    return on_boundary and x[0]>0.1

def update_inlet_outlet_bcs(branches, t, n):
    for branch_id, data in branches.items():

      # Retrieve the boundary conditions for the start of the branch
      left_boundary = data['boundary']['left']

      if left_boundary['type'] == 'inlet':

        if known_inflow_data == 'area':
          A_inlet = data['A0'] + 0.01 * t
          q_inlet = inlet_bc_q(data['Ah_old'], data['qh_old'], data['A0'], data['beta'], data['uh'].dx(0), data['V_der'], 0)

        elif known_inflow_data == 'flux':

          if branch_id == '1':
            inflow_data = inflow_data_BAS
          elif branch_id == '5':
            inflow_data = inflow_data_L_ICA
          elif branch_id == '12':
            inflow_data = inflow_data_R_ICA

          q_inlet = inflow_data[n][1] * branch_boundary_conditions[branch_id]['left']['A_left']
          A_inlet = inlet_bc_A(data['Ah_old'], data['qh_old'], data['A0'], data['beta'], data['uh'].dx(0), data['V_der'], 0)

        branch_boundary_conditions[branch_id]['left'] = {'A_left': A_inlet, 'q_left': q_inlet}

      elif left_boundary['type'] == 'outlet':
        A_outlet, q_outlet = outlet_bc(data['Ah_old'], data['qh_old'], data['A0'], data['beta'], data['uh'].dx(0), data['V_der'], 0)
        branch_boundary_conditions[branch_id]['left'] = {'A_left': A_outlet, 'q_left': q_outlet}

      # Retrieve the boundary conditions for the end of the branch
      right_boundary = data['boundary']['right']

      if right_boundary['type'] == 'inlet':

        if known_inflow_data == 'area':
          A_inlet = data['A0'] + 0.01 * t
          q_inlet = inlet_bc_q(data['Ah_old'], data['qh_old'], data['A0'], data['beta'], data['uh'].dx(0), data['V_der'], data['L'])

        elif known_inflow_data == 'flux':

          if branch_id == '1':
            inflow_data = inflow_data_BAS
          elif branch_id == '5':
            inflow_data = inflow_data_L_ICA
          elif branch_id == '12':
            inflow_data = inflow_data_R_ICA

          q_inlet = - inflow_data[n][1] * branch_boundary_conditions[branch_id]['right']['A_right']
          A_inlet = inlet_bc_A(data['Ah_old'], data['qh_old'], data['A0'], data['beta'], data['uh'].dx(0), data['V_der'],  data['L'])

        branch_boundary_conditions[branch_id]['right'] = {'A_right': A_inlet, 'q_right': q_inlet}

      elif right_boundary['type'] == 'outlet':
        A_outlet, q_outlet = outlet_bc(data['Ah_old'], data['qh_old'], data['A0'], data['beta'], data['uh'].dx(0), data['V_der'], data['L'])
        branch_boundary_conditions[branch_id]['right'] = {'A_right': A_outlet, 'q_right': q_outlet}

"""## Branching condition"""

def C_A_in(A, q, A0, beta, gamma):
  return beta / (2 * rho * A0 * sqrt(A)) - (q ** 2 / A ** 3) * (1 - 2 * gamma * np.sign(q))

def C_q_in(A, q, A0, gamma):
  return (q / A ** 2) * (1 - 2 * gamma * np.sign(q))

def b_in(A, q, A0, beta, gamma):
  return beta / rho * (A - 2 * sqrt(A * A0)) / (2 * A0 * sqrt(A)) + 0.5 * (q / A) ** 2 * (1 - 2 * gamma * np.sign(q))

def C_A_out(A, q, A0, theta, beta, gamma):
  return beta / (2 * rho * A0 * sqrt(A)) - (q ** 2 / A ** 3) * (1 + 2 * gamma * sqrt(2 * (1 - cos(theta))) * np.sign(q))

def C_q_out(A, q, A0, theta, gamma):
  return (q / A ** 2) * (1 + 2 * gamma * sqrt(2 * (1 - cos(theta))) * np.sign(q))

def b_out(A, q, A0, theta, beta, gamma):
  return beta / rho * (A - 2 * sqrt(A * A0)) / (2 * A0 * sqrt(A)) + 0.5 * (q / A) ** 2 * (1 + 2 * gamma * sqrt(2 * (1 - cos(theta))) * np.sign(q))

def compute_branch_value(data, connected_data1, connected_data2, bifurcation, positions, toll=1e-5):

    # Define positions
    x1 = data['L'] if positions[0] == 'right' else 0
    x2 = connected_data1['L'] if positions[1] == 'right' else 0
    x3 = connected_data2['L'] if positions[2] == 'right' else 0

    # Get old values
    A_branch_old_1 = data['Ah_old'](x1)
    A_branch_old_2 = connected_data1['Ah_old'](x2)
    A_branch_old_3 = connected_data2['Ah_old'](x3)

    q_branch_old_1 = data['qh_old'](x1)
    q_branch_old_2 = connected_data1['qh_old'](x2)
    q_branch_old_3 = connected_data2['qh_old'](x3)

    # Initialize old values for new branches
    A_branch_0_1 = A_branch_old_1
    A_branch_0_2 = A_branch_old_2
    A_branch_0_3 = A_branch_old_3

    q_branch_0_1 = q_branch_old_1
    q_branch_0_2 = q_branch_old_2
    q_branch_0_3 = q_branch_old_3

    # theta values
    theta_2 = bifurcation['theta'][1]
    theta_3 = bifurcation['theta'][2]

    err = float('inf')
    iter = 0

    while (err > toll) and (iter < 100):
        iter += 1

        lhs = np.zeros((6, 6))
        rhs = np.zeros(6)

        if positions[0] == 'right':
          lhs[0, 3] = 1
        else: 
          lhs[0, 3] = -1
        if positions[1] == 'right':
          lhs[0, 4] = 1
        else: 
          lhs[0, 4] = -1
        if positions[2] == 'right':
          lhs[0, 5] = 1
        else: 
          lhs[0, 5] = -1  

        lhs[1, 0] = C_A_in(A_branch_old_1, q_branch_old_1, data['A0'], data['beta'], gamma_1)
        lhs[1, 1] = -C_A_out(A_branch_old_2, q_branch_old_2, connected_data1['A0'], theta_2, connected_data1['beta'], gamma_2)
        lhs[1, 3] = C_q_in(A_branch_old_1, q_branch_old_1, data['A0'], gamma_1)
        lhs[1, 4] = -C_q_out(A_branch_old_2, q_branch_old_2, connected_data1['A0'], theta_2, gamma_2)

        lhs[2, 0] = C_A_in(A_branch_old_1, q_branch_old_1, data['A0'], data['beta'], gamma_1)
        lhs[2, 2] = -C_A_out(A_branch_old_3, q_branch_old_3, connected_data2['A0'], theta_3, connected_data2['beta'], gamma_3)
        lhs[2, 3] = C_q_in(A_branch_old_1, q_branch_old_1, data['A0'], gamma_1)
        lhs[2, 5] = -C_q_out(A_branch_old_3, q_branch_old_3, connected_data2['A0'], theta_3, gamma_3)

        if positions[0] == 'right':
          lhs[3, 0] = l1(A_branch_0_1, q_branch_0_1, data['A0'], data['beta'])[0]
          lhs[3, 3] = l1(A_branch_0_1, q_branch_0_1, data['A0'], data['beta'])[1]
        else:
          lhs[3, 0] = l2(A_branch_0_1, q_branch_0_1, data['A0'], data['beta'])[0]
          lhs[3, 3] = l2(A_branch_0_1, q_branch_0_1, data['A0'], data['beta'])[1]

        if positions[1] == 'right':
          lhs[4, 1] = l1(A_branch_0_2, q_branch_0_2, connected_data1['A0'], connected_data1['beta'])[0]
          lhs[4, 4] = l1(A_branch_0_2, q_branch_0_2, connected_data1['A0'], connected_data1['beta'])[1]
        else:
          lhs[4, 1] = l2(A_branch_0_2, q_branch_0_2, connected_data1['A0'], connected_data1['beta'])[0]
          lhs[4, 4] = l2(A_branch_0_2, q_branch_0_2, connected_data1['A0'], connected_data1['beta'])[1]

        if positions[2] == 'right':
          lhs[5, 2] = l1(A_branch_0_3, q_branch_0_3, connected_data2['A0'], connected_data2['beta'])[0]
          lhs[5, 5] = l1(A_branch_0_3, q_branch_0_3, connected_data2['A0'], connected_data2['beta'])[1]
        else:
          lhs[5, 2] = l2(A_branch_0_3, q_branch_0_3, connected_data2['A0'], connected_data2['beta'])[0]
          lhs[5, 5] = l2(A_branch_0_3, q_branch_0_3, connected_data2['A0'], connected_data2['beta'])[1]

        rhs[1] = b_out(A_branch_old_2, q_branch_old_2, connected_data1['A0'], theta_2, connected_data1['beta'], gamma_2) - b_in(A_branch_old_1, q_branch_old_1, data['A0'], data['beta'], gamma_1)
        rhs[2] = b_out(A_branch_old_3, q_branch_old_3, connected_data2['A0'], theta_3, connected_data2['beta'], gamma_3) - b_in(A_branch_old_1, q_branch_old_1, data['A0'], data['beta'], gamma_1)

        if positions[0] == 'right':
            rhs[3] = np.dot(l1(A_branch_0_1, q_branch_0_1, data['A0'], data['beta']), CC(A_branch_0_1, q_branch_0_1, data['A0'], data['beta'], data['uh'].dx(0), data['V_der'], x1))
        else:
            rhs[3] = np.dot(l2(A_branch_0_1, q_branch_0_1, data['A0'], data['beta']), CC(A_branch_0_1, q_branch_0_1, data['A0'], data['beta'], data['uh'].dx(0), data['V_der'], x1))

        if positions[1] == 'right':
            rhs[4] = np.dot(l1(A_branch_0_2, q_branch_0_2, connected_data1['A0'], connected_data1['beta']), CC(A_branch_0_2, q_branch_0_2, connected_data1['A0'], connected_data1['beta'], connected_data1['uh'].dx(0), connected_data1['V_der'], x2))
        else:
            rhs[4] = np.dot(l2(A_branch_0_2, q_branch_0_2, connected_data1['A0'], connected_data1['beta']), CC(A_branch_0_2, q_branch_0_2, connected_data1['A0'], connected_data1['beta'], connected_data1['uh'].dx(0), connected_data1['V_der'], x2))

        if positions[2] == 'right':
            rhs[5] = np.dot(l1(A_branch_0_3, q_branch_0_3, connected_data2['A0'], connected_data2['beta']), CC(A_branch_0_3, q_branch_0_3, connected_data2['A0'], connected_data2['beta'], connected_data2['uh'].dx(0), connected_data2['V_der'], x3))
        else:
            rhs[5] = np.dot(l2(A_branch_0_3, q_branch_0_3, connected_data2['A0'], connected_data2['beta']), CC(A_branch_0_3, q_branch_0_3, connected_data2['A0'], connected_data2['beta'], connected_data2['uh'].dx(0), connected_data2['V_der'], x3))


        A_branch_1, A_branch_2, A_branch_3, q_branch_1, q_branch_2, q_branch_3 = np.linalg.solve(lhs, rhs)

        if (q_branch_0_1 == 0) or (q_branch_0_2 == 0) or (q_branch_0_3 == 0):
            err = abs(A_branch_1 - A_branch_old_1) / A_branch_0_1 + abs(A_branch_2 - A_branch_old_2) / A_branch_0_2 + abs(A_branch_3 - A_branch_old_3) / A_branch_0_3 \
                + abs(q_branch_1 - q_branch_old_1) + abs(q_branch_2 - q_branch_old_2) + abs(q_branch_3 - q_branch_old_3)
        else:
            err = abs(A_branch_1 - A_branch_old_1) / A_branch_0_1 + abs(A_branch_2 - A_branch_old_2) / A_branch_0_2 + abs(A_branch_3 - A_branch_old_3) / A_branch_0_3 \
                + abs(q_branch_1 - q_branch_old_1) / q_branch_0_1 + abs(q_branch_2 - q_branch_old_2) / q_branch_0_2 + abs(q_branch_3 - q_branch_old_3) / q_branch_0_3

        A_branch_old_1 = A_branch_1
        A_branch_old_2 = A_branch_2
        A_branch_old_3 = A_branch_3

        q_branch_old_1 = q_branch_1
        q_branch_old_2 = q_branch_2
        q_branch_old_3 = q_branch_3

    res_2, res_3 = check_non_linear_system(
        A_branch_1, A_branch_2, A_branch_3,
        q_branch_1, q_branch_2, q_branch_3,
        data, connected_data1, connected_data2, bifurcation
    )

    #print(res_2, res_3)

    return A_branch_1, A_branch_2, A_branch_3, q_branch_1, q_branch_2, q_branch_3, err, iter

def g_1(A, q, gamma):
  return gamma * (q / A) ** 2

def g_i(A, q, gamma, theta):
  return gamma * (q / A) ** 2 * sqrt(2 * (1 - cos(theta)))

# Check if the linearized solution solve 2 non linear equations
def check_non_linear_system(A1, A2, A3, q1, q2, q3, data, connected_data1, connected_data2, bifurcation):
    theta_2 = bifurcation['theta'][1]
    theta_3 = bifurcation['theta'][2]

    res_2 = data['beta'] / (rho * data['A0']) * (np.sqrt(A1) - np.sqrt(data['A0'])) + 0.5 * (q1 / A1) ** 2 - np.sign(q1 / A1) * g_1(A1, q1, gamma_1) \
            - connected_data1['beta'] / (rho * connected_data1['A0']) * (np.sqrt(A2) - np.sqrt(connected_data1['A0'])) - 0.5 * (q2 / A2) ** 2 - np.sign(q2 / A2) * g_i(A2, q2, gamma_2, theta_2)

    res_3 = data['beta'] / (rho * data['A0']) * (np.sqrt(A1) - np.sqrt(data['A0'])) + 0.5 * (q1 / A1) ** 2 - np.sign(q1 / A1) * g_1(A1, q1, gamma_1) \
            - connected_data2['beta'] / (rho * connected_data2['A0']) * (np.sqrt(A3) - np.sqrt(connected_data2['A0'])) - 0.5 * (q3 / A3) ** 2 - np.sign(q3 / A3) * g_i(A3, q3, gamma_3, theta_3)

    return res_2, res_3

def handle_branching_points(bifurcations, branches, branch_boundary_conditions):
    for bif_id, bif_data in bifurcations.items():
        branch_id = bif_data['branch_id'][0]  # Main branch
        connected_branches = bif_data['branch_id'][1:]  # Connected branches

        if len(connected_branches) == 2:
            cb1_id, cb2_id = connected_branches
            main_data = branches[branch_id]
            connected_data1 = branches[cb1_id]
            connected_data2 = branches[cb2_id]
            positions = bif_data['positions']

            A_branch_1, A_branch_2, A_branch_3, q_branch_1, q_branch_2, q_branch_3, err, iter = compute_branch_value(
                main_data, connected_data1, connected_data2, bif_data, positions, toll=1e-5
            )

            # Update boundary conditions for the main branch
            if positions[0] == 'left':
                branch_boundary_conditions[branch_id]['left'] = {
                    'A_left': A_branch_1,
                    'q_left': q_branch_1
                }
            else:
                branch_boundary_conditions[branch_id]['right'] = {
                    'A_right': A_branch_1,
                    'q_right': q_branch_1
                }

            # Update boundary conditions for the connected branches
            if positions[1] == 'left':
                branch_boundary_conditions[cb1_id]['left'] = {
                    'A_left': A_branch_2,
                    'q_left': q_branch_2
                }
            else:
                branch_boundary_conditions[cb1_id]['right'] = {
                    'A_right': A_branch_2,
                    'q_right': q_branch_2
                }

            if positions[2] == 'left':
                branch_boundary_conditions[cb2_id]['left'] = {
                    'A_left': A_branch_3,
                    'q_left': q_branch_3
                }
            else:
                branch_boundary_conditions[cb2_id]['right'] = {
                    'A_right': A_branch_3,
                    'q_right': q_branch_3
                }
        else:
            raise ValueError("A branching point should connect to exactly two branches.")

"""## Definition and solution of local variational problem"""

def LinearProblem(bc, V, A_old, q_old, A0, beta):
  # Define trial functions and test functions
  A, q = TrialFunctions(V)
  v, z = TestFunctions(V)
  uh = Function(V)

  a = inner(A, v) * dx + inner(q, z) * dx

  l = (
        A_old * v * dx
      + q_old * z * dx
      + dt * ((F(A_old, q_old, A0, beta) - dt / 2 * dot(H(A_old, q_old, A0, beta), S(A_old, q_old))))[0] * v.dx(0) * dx
      + dt * ((F(A_old, q_old, A0, beta) - dt / 2 * dot(H(A_old, q_old, A0, beta), S(A_old, q_old))))[1] * z.dx(0) * dx
      + dt ** 2 / 2 * (dot(dS_dU(A_old, q_old), F(A_old, q_old, A0, beta).dx(0)))[0] * v * dx
      + dt ** 2 / 2 * (dot(dS_dU(A_old, q_old), F(A_old, q_old, A0, beta).dx(0)))[1] * z * dx
      - dt ** 2 / 2 * (dot(H(A_old, q_old, A0, beta), F(A_old, q_old, A0, beta).dx(0)))[0] * v.dx(0) * dx
      - dt ** 2 / 2 * (dot(H(A_old, q_old, A0, beta), F(A_old, q_old, A0, beta).dx(0)))[1] * z.dx(0) * dx
      - dt * (S(A_old, q_old) - dt / 2 * dot(dS_dU(A_old, q_old), S(A_old, q_old)))[0] * v * dx
      - dt * (S(A_old, q_old) - dt / 2 * dot(dS_dU(A_old, q_old), S(A_old, q_old)))[1] * z * dx
  )

  solve(a == l, uh, bc)

  return uh

def solve_local_branches(branches, branch_boundary_conditions):
    results = {branch_id: {'A': [], 'q': []} for branch_id in branches.keys()}
    for branch_id, data in branches.items():
        # Extract boundary conditions
        bc_data = branch_boundary_conditions.get(branch_id, {})

        A_left = bc_data.get('left', {}).get('A_left', None)
        q_left = bc_data.get('left', {}).get('q_left', None)
        A_right = bc_data.get('right', {}).get('A_right', None)
        q_right = bc_data.get('right', {}).get('q_right', None)

        # Initialize boundary conditions
        bcs = []

        if A_left is not None and q_left is not None:
            bc_A_left = DirichletBC(data['V'].sub(0), A_left, boundary_L)
            bc_q_left = DirichletBC(data['V'].sub(1), q_left, boundary_L)
            bcs.extend([bc_A_left, bc_q_left])

        if A_right is not None and q_right is not None:
            bc_A_right = DirichletBC(data['V'].sub(0), A_right, boundary_R)
            bc_q_right = DirichletBC(data['V'].sub(1), q_right, boundary_R)
            bcs.extend([bc_A_right, bc_q_right])

        # Solve the local problem
        uh = LinearProblem(bcs, data['V'], data['Ah_old'], data['qh_old'], data['A0'], data['beta'])
        Ah, qh = uh.split(deepcopy=True)
        data['uh'] = uh  # Store the computed solution
        data['Ah_old'].assign(Ah)
        data['qh_old'].assign(qh)

        # Store the results
        results[branch_id]['A'] = Ah.compute_vertex_values(data['mesh'])
        results[branch_id]['q'] = qh.compute_vertex_values(data['mesh'])

        results_total[branch_id]['A'].append(Ah.compute_vertex_values(data['mesh']))
        results_total[branch_id]['q'].append(qh.compute_vertex_values(data['mesh']))
    
    return results

def save_results_to_pickle(results, timestep):
    filename = f'alpha_1.333/t_{timestep}.pkl'
    with open(filename, 'wb') as f:
        pickle.dump(results, f)

"""## Plot"""

def plot_branches_combined(branches, n, num_cols=5):
    num_branches = len(branches)
    num_rows = (num_branches + num_cols - 1) // num_cols  # Calculate required rows

    # Create a figure with subplots for both area and flux
    fig, axes = plt.subplots(num_rows * 2, num_cols, figsize=(num_cols * 3.8, num_rows * 8))
    axes = axes.flatten()

    for i, (branch_name, branch_data) in enumerate(branches.items()):
        if i >= num_cols * num_rows:  # Ensure we do not exceed the available axes
            break

        # Plot area in red on the first row
        ax_area = axes[i]
        Ah_old = branch_data['Ah_old']
        mesh = branch_data['mesh']
        ax_area.plot(mesh.coordinates(), Ah_old.compute_vertex_values(mesh), 'r', label='Area')
        ax_area.set_title(f'{branch_name}')
        ax_area.legend()

        # Plot flux in blue on the second row
        ax_flux = axes[num_cols * num_rows + i]
        qh_old = branch_data['qh_old']
        ax_flux.plot(mesh.coordinates(), qh_old.compute_vertex_values(mesh), 'b', label='Flux')
        ax_flux.legend()

    # Hide any unused subplots
    for j in range(i + 1, num_cols * num_rows):
        fig.delaxes(axes[j])
        fig.delaxes(axes[num_cols * num_rows + j])

    # Set global title
    fig.suptitle(f'Area and Flux Profile at Time Step {n}', fontsize=16)

    plt.tight_layout(rect=[0, 0, 1, 0.92])  # Adjust layout to make room for the global title
    plt.show()

"""# Solution"""

# Time stepping
t = 0

# Initialize branches
initialize_branches(branches)
results_total = {branch_id: {'A': [], 'q': []} for branch_id in branches.keys()}

for n in tqdm(range(N_T + 1)):
    # Solve the problem for each branch
    results = solve_local_branches(branches, branch_boundary_conditions)

    # Update time step
    t += dt

    # Update boundary conditions for inlets and outlets
    update_inlet_outlet_bcs(branches, t, 2 * (n % N_T_base))    

    # Handle branching points
    handle_branching_points(bifurcations, branches, branch_boundary_conditions)

    # Save results every 100 time steps
    # if n % 100 == 0 and n != 0:
    #     save_results_to_pickle(results, n)

    # if n % 2211 == 0:
      # plot_branches_combined(branches, n)

with open('close_network_gamma2.pkl', 'wb') as f:
    pickle.dump(results_total, f)

plot_branches_combined(branches, n)